"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[758],{1668:function(e,t,o){o.r(t),o.d(t,{contentTitle:function(){return p},default:function(){return v},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return c}});var n=o(7462),i=o(3366),r=(o(7294),o(3905)),a=(o(6396),o(8215),o(9055)),d=o(4214),s=["components"],l={title:"Provider"},p=void 0,u={unversionedId:"providers/provider",id:"providers/provider",title:"Provider",description:"p\xe1gina n\xe3o traduzida, ainda.",source:"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/providers/provider.mdx",sourceDirName:"providers",slug:"/providers/provider",permalink:"/docs/providers/provider",editUrl:"https://github.com/rrousselGit/river_pod/edit/master/website/i18n/pt-BR/docusaurus-plugin-content-docs/current/providers/provider.mdx",tags:[],version:"current",frontMatter:{title:"Provider"},sidebar:"Sidebar",previous:{title:"^0.14.0 to ^1.0.0",permalink:"/docs/migration/0.14.0_to_1.0.0"},next:{title:"StateNotifierProvider",permalink:"/docs/providers/state_notifier_provider"}},c=[{value:"Using <code>Provider</code> to cache computations",id:"using-provider-to-cache-computations",children:[],level:2},{value:"Reducing provider/widget rebuilds by using <code>Provider</code>",id:"reducing-providerwidget-rebuilds-by-using-provider",children:[],level:2}],h={toc:c};function v(e){var t=e.components,o=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"p\xe1gina n\xe3o traduzida, ainda."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Provider")," is the most basic of all providers. It creates a value... And that's about it."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Provider")," is typically used for:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"caching computations"),(0,r.kt)("li",{parentName:"ul"},"exposing a value to other providers (such as a ",(0,r.kt)("inlineCode",{parentName:"li"},"Repository"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"HttpClient"),")."),(0,r.kt)("li",{parentName:"ul"},"offering a way for tests or widgets to override a value."),(0,r.kt)("li",{parentName:"ul"},"reducing rebuilds of providers/widgets without having to use ",(0,r.kt)("inlineCode",{parentName:"li"},"select"),".")),(0,r.kt)("h2",{id:"using-provider-to-cache-computations"},"Using ",(0,r.kt)("inlineCode",{parentName:"h2"},"Provider")," to cache computations"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Provider")," is a powerful tool for caching synchronous operations when combined\nwith ",(0,r.kt)("a",{parentName:"p",href:"../concepts/reading#using-refwatch-to-observe-a-provider"},"ref.watch"),"."),(0,r.kt)("p",null,"An example would be filtering a list of todos.\nSince filtering a list could be slightly expensive, we ideally do not want to\nfilter our list of todos whenever our application re-renders.\nIn this situation, we could use ",(0,r.kt)("inlineCode",{parentName:"p"},"Provider")," to do the filtering for us."),(0,r.kt)("p",null,"For that, assume that our application has an existing ",(0,r.kt)("a",{parentName:"p",href:"./state_notifier_provider"},"StateNotifierProvider"),"\nwhich manipulates a list of todos:"),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},(0,d.m)("// ignore_for_file: avoid_positional_boolean_parameters\n\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n/* SNIPPET START */\n\nclass Todo {\n  Todo(this.description, this.isCompleted);\n  final bool isCompleted;\n  final String description;\n}\n\nclass TodosNotifier extends StateNotifier<List<Todo>> {\n  TodosNotifier() : super([]);\n\n  void addTodo(Todo todo) {\n    state = [...state, todo];\n  }\n  // TODO add other methods, such as \"removeTodo\", ...\n}\n\nfinal todosProvider = StateNotifierProvider<TodosNotifier, List<Todo>>((ref) {\n  return TodosNotifier();\n});\n")),(0,r.kt)("p",null,"From there, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"Provider")," to expose the filtered list of todos, showing\nonly the completed todos:"),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},(0,d.m)("import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nimport 'todo.dart';\n\n/* SNIPPET START */\n\nfinal completedTodosProvider = Provider<List<Todo>>((ref) {\n  // We obtain the list of all todos from the todosProvider\n  final todos = ref.watch(todosProvider);\n\n  // we return only the completed todos\n  return todos.where((todo) => todo.isCompleted).toList();\n});\n")),(0,r.kt)("p",null,"With this code, our UI is now able to show the list of the completed todos\nby listening to ",(0,r.kt)("inlineCode",{parentName:"p"},"completedTodosProvider"),":"),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},(0,d.m)("// ignore_for_file: unused_local_variable\n\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nimport 'completed_todos.dart';\n\nWidget build() {\nreturn\n/* SNIPPET START */\nConsumer(builder: (context, ref, child) {\n  final completedTodos = ref.watch(completedTodosProvider);\n  // TODO show the todos using a ListView/GridView/.../* SKIP */\n  return Container();\n  /* SKIP END */\n});\n/* SNIPPET END */\n}\n")),(0,r.kt)("p",null,"The interesting part is, the list filtering is now cached."),(0,r.kt)("p",null,"Meaning that the list of completed todos will not be recomputed until\ntodos are added/removed/updated, even if we are reading the list of completed\ntodos multiple times."),(0,r.kt)("p",null,"Note how we do not need to manually invalidate the cache when the list of todos\nchanges. ",(0,r.kt)("inlineCode",{parentName:"p"},"Provider")," is automatically able to know when the result must be recomputed\nthanks to ",(0,r.kt)("a",{parentName:"p",href:"../concepts/reading#using-refwatch-to-observe-a-provider"},"ref.watch"),"."),(0,r.kt)("h2",{id:"reducing-providerwidget-rebuilds-by-using-provider"},"Reducing provider/widget rebuilds by using ",(0,r.kt)("inlineCode",{parentName:"h2"},"Provider")),(0,r.kt)("p",null,"A unique aspect of ",(0,r.kt)("inlineCode",{parentName:"p"},"Provider")," is that even when ",(0,r.kt)("inlineCode",{parentName:"p"},"Provider")," is recomputed\n(typically when using ",(0,r.kt)("a",{parentName:"p",href:"../concepts/reading#using-refwatch-to-observe-a-provider"},"ref.watch"),"), it will not update the widgets/providers\nthat listen to it unless the value changed."),(0,r.kt)("p",null,"A real world example would be for enabling/disabling previous/next buttons\nof a paginated view:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/134939/47580830-31263a00-d950-11e8-9b61-0eaddab2709e.png",alt:"stepper example"})),(0,r.kt)("p",null,'In our case, we will focus specifically on the "previous" button.',(0,r.kt)("br",{parentName:"p"}),"\n","A na\xefve implementation of such button would be a widget which obtains the\ncurrent page index, and if that index is equal to 0, we would disable the button."),(0,r.kt)("p",null,"This code could be:"),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},(0,d.m)("// A provider that controls the current page\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n/* SNIPPET START */\n\nfinal pageIndexProvider = StateProvider<int>((ref) => 0);\n\nclass PreviousButton extends ConsumerWidget {\n  const PreviousButton({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // if not on first page, the previous button is active\n    final canGoToPreviousPage = ref.watch(pageIndexProvider) != 0;\n\n    void goToPreviousPage() {\n      ref.read(pageIndexProvider.notifier).update((state) => state - 1);\n    }\n\n    return ElevatedButton(\n      onPressed: canGoToPreviousPage ? null : goToPreviousPage,\n      child: const Text('previous'),\n    );\n  }\n}")),(0,r.kt)("p",null,'The issue with this code is that whenever we change the current page, the "previous"\nbutton will rebuild.',(0,r.kt)("br",{parentName:"p"}),"\n","In the ideal world, we would want the button to rebuild only when changing between\nactivated and deactivated."),(0,r.kt)("p",null,'The root of the issue here is that we are computing whether the user is\nallowed to go to the previous page directly within the "previous" button.'),(0,r.kt)("p",null,"A way to solve this is to extract this logic outside of the widget and into a ",(0,r.kt)("inlineCode",{parentName:"p"},"Provider"),":"),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},(0,d.m)("// A provider that controls the current page\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n/* SNIPPET START */\n\nfinal pageIndexProvider = StateProvider<int>((ref) => 0);\n\n// A provider which computes whether the user is allowed to go to the previous page\n/* highlight-start */\nfinal canGoToPreviousPageProvider = Provider<bool>((ref) {\n/* highlight-end */\n  return ref.watch(pageIndexProvider) != 0;\n});\n\nclass PreviousButton extends ConsumerWidget {\n  const PreviousButton({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // We are now watching our new Provider\n    // Our widget is no longer calculating whether we can go to the previous page.\n/* highlight-start */\n    final canGoToPreviousPage = ref.watch(canGoToPreviousPageProvider);\n/* highlight-end */\n\n    void goToPreviousPage() {\n      ref.read(pageIndexProvider.notifier).update((state) => state - 1);\n    }\n\n    return ElevatedButton(\n      onPressed: canGoToPreviousPage ? null : goToPreviousPage,\n      child: const Text('previous'),\n    );\n  }\n}")),(0,r.kt)("p",null,"By doing this small refactoring, our ",(0,r.kt)("inlineCode",{parentName:"p"},"PreviousButton")," widget will no longer\nrebuild when the page index changes thanks to ",(0,r.kt)("inlineCode",{parentName:"p"},"Provider"),"."),(0,r.kt)("p",null,"From now on when the page index changes, our ",(0,r.kt)("inlineCode",{parentName:"p"},"canGoToPreviousPageProvider")," provider\nwill be recomputed. But if the value exposed by the provider does not change,\nthen ",(0,r.kt)("inlineCode",{parentName:"p"},"PreviousButton")," will not rebuild."),(0,r.kt)("p",null,"This change both improved the performance of our button and had the interesting\nbenefit of extracting the logic outside of our widget."))}v.isMDXComponent=!0}}]);