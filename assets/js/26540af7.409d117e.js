"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[575],{855:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return u},metadata:function(){return v},toc:function(){return h}});var r=n(7462),o=n(3366),i=(n(7294),n(3905)),a=n(6396),s=n(8215),d=n(9055),l=n(4214),p=["components"],u={title:"Testing"},c=void 0,v={unversionedId:"cookbooks/testing",id:"cookbooks/testing",title:"Testing",description:"p\xe1gina n\xe3o traduzida, ainda.",source:"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx",sourceDirName:"cookbooks",slug:"/cookbooks/testing",permalink:"/riverpod/docs/cookbooks/testing",editUrl:"https://github.com/rrousselGit/river_pod/edit/master/website/i18n/pt-BR/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx",tags:[],version:"current",frontMatter:{title:"Testing"},sidebar:"Sidebar",previous:{title:"ProviderObserver",permalink:"/riverpod/docs/concepts/provider_observer"},next:{title:"^0.13.0 to ^0.14.0",permalink:"/riverpod/docs/migration/0.13.0_to_0.14.0"}},h=[{value:"No state should be preserved between <code>test</code>/<code>testWidgets</code>.",id:"no-state-should-be-preserved-between-testtestwidgets",children:[],level:2},{value:"Overriding the behavior of a provider during tests.",id:"overriding-the-behavior-of-a-provider-during-tests",children:[],level:2},{value:"Full widget test example",id:"full-widget-test-example",children:[],level:2}],m={toc:h};function f(e){var t=e.components,n=(0,o.Z)(e,p);return(0,i.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"p\xe1gina n\xe3o traduzida, ainda."),(0,i.kt)("p",null,"For any medium to large-scale applications, it is critical to test the application."),(0,i.kt)("p",null,"To successfully test our application, we will want the following things:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"No state should be preserved between ",(0,i.kt)("inlineCode",{parentName:"p"},"test"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"testWidgets"),".",(0,i.kt)("br",{parentName:"p"}),"\n","That means no global state in the application, or all global states should reset after each test.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Being able to force our providers to have a specific state, either through\nmocking or by manipulating them until we reach the desired state."))),(0,i.kt)("p",null,"Let's see one by one how ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/rrousselgit/river_pod"},"Riverpod")," helps you with these."),(0,i.kt)("h2",{id:"no-state-should-be-preserved-between-testtestwidgets"},"No state should be preserved between ",(0,i.kt)("inlineCode",{parentName:"h2"},"test"),"/",(0,i.kt)("inlineCode",{parentName:"h2"},"testWidgets"),"."),(0,i.kt)("p",null,"Since providers are usually declared as global variables, you might worry about\nthat one.",(0,i.kt)("br",{parentName:"p"}),"\n","After all, global state makes testing very difficult, because it can require\nlengthy ",(0,i.kt)("inlineCode",{parentName:"p"},"setUp"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"tearDown"),"."),(0,i.kt)("p",null,"But the reality is: While providers are declared as globals, the state of a provider\nis ",(0,i.kt)("strong",{parentName:"p"},"not")," global."),(0,i.kt)("p",null,"Instead, it is stored in an object named ",(0,i.kt)("a",{parentName:"p",href:"https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html"},"ProviderContainer"),", which you may have\nseen if you looked at the dart-only examples.",(0,i.kt)("br",{parentName:"p"}),"\n","If you haven't, know that this ",(0,i.kt)("a",{parentName:"p",href:"https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html"},"ProviderContainer")," object is implicitly created\nby ",(0,i.kt)("a",{parentName:"p",href:"https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html"},"ProviderScope"),", the widget that enables ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/rrousselgit/river_pod"},"Riverpod")," on our project."),(0,i.kt)("p",null,"Concretely what this means is, two ",(0,i.kt)("inlineCode",{parentName:"p"},"testWidgets")," using providers do not share\nany state.",(0,i.kt)("br",{parentName:"p"}),"\n","As such, there is no need for any ",(0,i.kt)("inlineCode",{parentName:"p"},"setUp"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"tearDown")," at all."),(0,i.kt)("p",null,"But an example is better than lengthy explanations:"),(0,i.kt)(a.Z,{defaultValue:"testWidgets",values:[{label:"testWidgets (Flutter)",value:"testWidgets"},{label:"test (Dart only)",value:"test"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"testWidgets",mdxType:"TabItem"},(0,i.kt)(d.Z,{mdxType:"CodeBlock"},(0,l.m)("// ignore_for_file: use_key_in_widget_constructors\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\n/* SNIPPET START */\n\n// A Counter implemented and tested using Flutter\n\n// We declared a provider globally, and we will use it in two tests, to see\n// if the state correctly resets to `0` between tests.\n\nfinal counterProvider = StateProvider((ref) => 0);\n\n// Renders the current state and a button that allows incrementing the state\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Consumer(builder: (context, ref, _) {\n        final counter = ref.watch(counterProvider);\n        return ElevatedButton(\n          onPressed: () => ref.read(counterProvider.notifier).state++,\n          child: Text('$counter'),\n        );\n      }),\n    );\n  }\n}\n\nvoid main() {\n  testWidgets('update the UI when incrementing the state', (tester) async {\n    await tester.pumpWidget(ProviderScope(child: MyApp()));\n\n    // The default value is `0`, as declared in our provider\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    // Increment the state and re-render\n    await tester.tap(find.byType(ElevatedButton));\n    await tester.pump();\n\n    // The state have properly incremented\n    expect(find.text('1'), findsOneWidget);\n    expect(find.text('0'), findsNothing);\n  });\n\n  testWidgets('the counter state is not shared between tests', (tester) async {\n    await tester.pumpWidget(ProviderScope(child: MyApp()));\n\n    // The state is `0` once again, with no tearDown/setUp needed\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n  });\n}\n"))),(0,i.kt)(s.Z,{value:"test",mdxType:"TabItem"},(0,i.kt)(d.Z,{mdxType:"CodeBlock"},(0,l.m)("import 'package:flutter_test/flutter_test.dart';\nimport 'package:mockito/mockito.dart';\nimport 'package:riverpod/riverpod.dart';\n\n/* SNIPPET START */\n\n// A Counter implemented and tested with Dart only (no dependency on Flutter)\n\n// We declared a provider globally, and we will use it in two tests, to see\n// if the state correctly resets to `0` between tests.\n\nfinal counterProvider = StateProvider((ref) => 0);\n\n// Using mockito to keep track of when a provider notify its listeners\nclass Listener extends Mock {\n  void call(int? previous, int value);\n}\n\nvoid main() {\n  test('defaults to 0 and notify listeners when value changes', () {\n    // An object that will allow us to read providers\n    // Do not share this between tests.\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n    final listener = Listener();\n\n    // Observe a provider and spy the changes.\n    container.listen<int>(\n      counterProvider,\n      listener,\n      fireImmediately: true,\n    );\n\n    // the listener is called immediately with 0, the default value\n    verify(listener(null, 0)).called(1);\n    verifyNoMoreInteractions(listener);\n\n    // We increment the value\n    container.read(counterProvider.notifier).state++;\n\n    // The listener was called again, but with 1 this time\n    verify(listener(0, 1)).called(1);\n    verifyNoMoreInteractions(listener);\n  });\n\n  test('the counter state is not shared between tests', () {\n    // We use a different ProviderContainer to read our provider.\n    // This ensure that no state is reused between tests\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n    final listener = Listener();\n\n    container.listen<int>(\n      counterProvider,\n      listener,\n      fireImmediately: true,\n    );\n\n    // The new test correctly uses the default value: 0\n    verify(listener(null, 0)).called(1);\n    verifyNoMoreInteractions(listener);\n  });\n}\n")))),(0,i.kt)("p",null,"As you can see, while ",(0,i.kt)("inlineCode",{parentName:"p"},"counterProvider")," was declared as a global, no state was\nshared between tests.",(0,i.kt)("br",{parentName:"p"}),"\n","As such, we do not have to worry about our tests potentially behaving differently\nif executed in a different order, since they are running in complete isolation."),(0,i.kt)("h2",{id:"overriding-the-behavior-of-a-provider-during-tests"},"Overriding the behavior of a provider during tests."),(0,i.kt)("p",null,"A common real-world application may have the following objects:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It will have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Repository")," class, which provides a type-safe and simple API\nto perform HTTP requests.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"An object that manages the application state, and may use ",(0,i.kt)("inlineCode",{parentName:"p"},"Repository")," to perform\nHTTP requests based on different factors.\nThis may be a ",(0,i.kt)("inlineCode",{parentName:"p"},"ChangeNotifier"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Bloc"),", or even a provider."))),(0,i.kt)("p",null,"Using ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/rrousselgit/river_pod"},"Riverpod"),", this may be represented as follows:"),(0,i.kt)(d.Z,{mdxType:"CodeBlock"},(0,l.m)("import 'package:hooks_riverpod/hooks_riverpod.dart';\n\nclass Todo {}\n\n/* SNIPPET START */\n\nclass Repository {\n  Future<List<Todo>> fetchTodos() async => [];\n}\n\n// We expose our instance of Repository in a provider\nfinal repositoryProvider = Provider((ref) => Repository());\n\n/// The list of todos. Here, we are simply fetching them from the server using\n/// [Repository] and doing nothing else.\nfinal todoListProvider = FutureProvider((ref) async {\n  // Obtains the Repository instance\n  final repository = ref.watch(repositoryProvider);\n\n  // Fetch the todos and expose them to the UI.\n  return repository.fetchTodos();\n});\n")),(0,i.kt)("p",null,"In this situation, when making a unit/widget test, we will typically want to\nreplace our ",(0,i.kt)("inlineCode",{parentName:"p"},"Repository")," instance with a fake implementation that returns\na pre-defined response instead of making a real HTTP request."),(0,i.kt)("p",null,"We will then want our ",(0,i.kt)("inlineCode",{parentName:"p"},"todoListProvider")," or equivalent to use the mocked implementation\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"Repository"),"."),(0,i.kt)("p",null,"To achieve this, we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"overrides")," parameter of ",(0,i.kt)("a",{parentName:"p",href:"https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html"},"ProviderScope"),"/",(0,i.kt)("a",{parentName:"p",href:"https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html"},"ProviderContainer"),"\nto override the behavior of ",(0,i.kt)("inlineCode",{parentName:"p"},"repositoryProvider"),":"),(0,i.kt)(a.Z,{defaultValue:"ProviderScope",values:[{label:"ProviderScope (Flutter)",value:"ProviderScope"},{label:"ProviderContainer (Dart only)",value:"ProviderContainer"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"ProviderScope",mdxType:"TabItem"},(0,i.kt)(d.Z,{mdxType:"CodeBlock"},(0,l.m)("import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nclass MyApp extends StatelessWidget {\n  // ignore: prefer_const_constructors_in_immutables\n  MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container();\n  }\n}\n\nfinal repositoryProvider = Provider((ref) => FakeRepository());\n\nclass FakeRepository {}\n\nvoid main() {\n/* SNIPPET START */\n\ntestWidgets('override repositoryProvider', (tester) async {\n  await tester.pumpWidget(\n    ProviderScope(\n      overrides: [\n        // Override the behavior of repositoryProvider to return\n        // FakeRepository instead of Repository.\n        /* highlight-start */\n        repositoryProvider.overrideWithValue(FakeRepository())\n        /* highlight-end */\n        // We do not have to override `todoListProvider`, it will automatically\n        // use the overridden repositoryProvider\n      ],\n      child: MyApp(),\n    ),\n  );\n});\n\n/* SNIPPET END */\n}\n"))),(0,i.kt)(s.Z,{value:"ProviderContainer",mdxType:"TabItem"},(0,i.kt)(d.Z,{mdxType:"CodeBlock"},(0,l.m)("import 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nclass FakeRepository {}\n\nfinal repositoryProvider = Provider((ref) => FakeRepository());\n\nabstract class Todo {\n  String get id;\n  String get label;\n  bool get completed;\n}\n\nfinal todoListProvider = FutureProvider<List<Todo>>((ref) => []);\n\nvoid main() {\n/* SNIPPET START */\n\ntest('override repositoryProvider', () async {\n  final container = ProviderContainer(\n    overrides: [\n      // Override the behavior of repositoryProvider to return\n      // FakeRepository instead of Repository.\n      /* highlight-start */\n      repositoryProvider.overrideWithValue(FakeRepository())\n      /* highlight-end */\n      // We do not have to override `todoListProvider`, it will automatically\n      // use the overridden repositoryProvider\n    ],\n  );\n\n  // The first read if the loading state\n  expect(\n    container.read(todoListProvider),\n    const AsyncValue<List<Todo>>.loading(),\n  );\n\n  /// Wait for the request to finish\n  await container.read(todoListProvider.future);\n\n  // Exposes the data fetched\n  expect(container.read(todoListProvider).value, [\n    isA<Todo>()\n        .having((s) => s.id, 'id', '42')\n        .having((s) => s.label, 'label', 'Hello world')\n        .having((s) => s.completed, 'completed', false),\n  ]);\n});\n\n/* SNIPPET END */\n}\n")))),(0,i.kt)("p",null,"As you can see by the highlighted code, ",(0,i.kt)("a",{parentName:"p",href:"https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html"},"ProviderScope"),"/",(0,i.kt)("a",{parentName:"p",href:"https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html"},"ProviderContainer"),"\nallows replacing the implementation of a provider with a different behavior."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Some providers expose simplified ways to override their behavior.",(0,i.kt)("br",{parentName:"p"}),"\n","For example, ",(0,i.kt)("a",{parentName:"p",href:"../providers/future_provider"},"FutureProvider")," allows overriding the provider with an ",(0,i.kt)("inlineCode",{parentName:"p"},"AsyncValue"),":"),(0,i.kt)(d.Z,{mdxType:"CodeBlock"},(0,l.m)("// ignore_for_file: avoid_unused_constructor_parameters\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  Todo({\n    required String id,\n    required String label,\n    required bool completed,\n  });\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container();\n  }\n}\n\n/* SNIPPET START */\n\nfinal todoListProvider = FutureProvider((ref) async => <Todo>[]);\n// ...\n/* SKIP */\nfinal foo =\n/* SKIP END */\nProviderScope(\n  overrides: [\n    /// Allows overriding a FutureProvider to return a fixed value\n    todoListProvider.overrideWithValue(\n      AsyncValue.data([Todo(id: '42', label: 'Hello', completed: true)]),\n    ),\n  ],\n  child: const MyApp(),\n);\n")))),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"The syntax for overriding a provider with the ",(0,i.kt)("inlineCode",{parentName:"p"},"family")," modifier is slightly different."),(0,i.kt)("p",{parentName:"div"},"If you used a provider like this:"),(0,i.kt)("pre",{parentName:"div"},(0,i.kt)("code",{parentName:"pre",className:"language-dart"},"final response = ref.watch(myProvider('12345'));\n")),(0,i.kt)("p",{parentName:"div"},"You could override the provider as:"),(0,i.kt)("pre",{parentName:"div"},(0,i.kt)("code",{parentName:"pre",className:"language-dart"},"myProvider('12345').overrideWithValue(...));\n")))),(0,i.kt)("h2",{id:"full-widget-test-example"},"Full widget test example"),(0,i.kt)("p",null,"Wrapping up, here is the entire full code for our Flutter test."),(0,i.kt)(d.Z,{mdxType:"CodeBlock"},(0,l.m)("\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nclass Repository {\n  Future<List<Todo>> fetchTodos() async => [];\n}\n\nclass Todo {\n  Todo({\n    required this.id,\n    required this.label,\n    required this.completed,\n  });\n\n  final String id;\n  final String label;\n  final bool completed;\n}\n\n// We expose our instance of Repository in a provider\nfinal repositoryProvider = Provider((ref) => Repository());\n\n/// The list of todos. Here, we are simply fetching them from the server using\n/// [Repository] and doing nothing else.\nfinal todoListProvider = FutureProvider((ref) async {\n  // Obtains the Repository instance\n  final repository = ref.read(repositoryProvider);\n\n  // Fetch the todos and expose them to the UI.\n  return repository.fetchTodos();\n});\n\n/// A mocked implementation of Repository that returns a pre-defined list of todos\nclass FakeRepository implements Repository {\n  @override\n  Future<List<Todo>> fetchTodos() async {\n    return [\n      Todo(id: '42', label: 'Hello world', completed: false),\n    ];\n  }\n}\n\nclass TodoItem extends StatelessWidget {\n  const TodoItem({Key? key, required this.todo}) : super(key: key);\n  final Todo todo;\n  @override\n  Widget build(BuildContext context) {\n    return Text(todo.label);\n  }\n}\n\nvoid main() {\n  testWidgets('override repositoryProvider', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\n          repositoryProvider.overrideWithValue(FakeRepository())\n        ],\n        // Our application, which will read from todoListProvider to display the todo-list.\n        // You may extract this into a MyApp widget\n        child: MaterialApp(\n          home: Scaffold(\n            body: Consumer(builder: (context, ref, _) {\n              final todos = ref.watch(todoListProvider);\n              // The list of todos is loading or in error\n              if (todos.asData == null) {\n                return const CircularProgressIndicator();\n              }\n              return ListView(\n                children: [\n                  for (final todo in todos.asData!.value) TodoItem(todo: todo)\n                ],\n              );\n            }),\n          ),\n        ),\n      ),\n    );\n\n    // The first frame is a loading state.\n    expect(find.byType(CircularProgressIndicator), findsOneWidget);\n\n    // Re-render. TodoListProvider should have finished fetching the todos by now\n    await tester.pump();\n\n    // No longer loading\n    expect(find.byType(CircularProgressIndicator), findsNothing);\n\n    // Rendered one TodoItem with the data returned by FakeRepository\n    expect(tester.widgetList(find.byType(TodoItem)), [\n      isA<TodoItem>()\n          .having((s) => s.todo.id, 'todo.id', '42')\n          .having((s) => s.todo.label, 'todo.label', 'Hello world')\n          .having((s) => s.todo.completed, 'todo.completed', false),\n    ]);\n  });\n}")))}f.isMDXComponent=!0}}]);